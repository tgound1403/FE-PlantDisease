{"ast":null,"code":"// Support regenerator-runtime globally.\nimport \"regenerator-runtime/runtime.js\";\nimport Base64 from \"./core/base64.js\";\nimport Converter from \"./core/converter.js\";\nimport File from \"./core/file.js\";\nimport Image from \"./core/image.js\";\nimport Photo from \"./core/photo.js\";\nimport Rotate from \"./core/rotate.js\"; // Supported input formats\n// image/png, image/jpeg, image/jpg, image/gif, image/bmp, image/tiff, image/x-icon,  image/svg+xml, image/webp, image/xxx\n// image/png, image/jpeg, image/webp\n\nexport default class Compress {\n  attach(el, options) {\n    return new Promise(resolve => {\n      const input = document.querySelector(el);\n      input.setAttribute(\"accept\", \"image/*\");\n      input.addEventListener(\"change\", evt => {\n        const output = this.compress([...evt.target.files], options);\n        resolve(output);\n      }, false);\n    });\n  }\n\n  compress(files, options) {\n    return Promise.all(files.map(file => compressFile(file, options)));\n  }\n\n  static convertBase64ToFile(base64, mime) {\n    return Converter.base64ToFile(base64, mime);\n  }\n\n}\n\nfunction loopCompression(canvas, size, quality = 1, targetSize, targetQuality = 1, iterations = 1) {\n  const base64str = Converter.canvasToBase64(canvas, quality);\n  const newSize = Base64.size(base64str);\n  return newSize > targetSize || quality > targetQuality ? loopCompression(canvas, newSize, quality - 0.1, targetSize, targetQuality, iterations + 1) : base64str;\n}\n\nasync function compressFile(file, options) {\n  // Create a new photo object\n  const photo = new Photo(options);\n  photo.start = window.performance.now();\n  photo.alt = file.name;\n  photo.ext = file.type;\n  photo.startSize = file.size;\n  photo.orientation = photo.rotate ? await Rotate.orientation(file) : 0;\n  return compressImage(photo)(await File.load(file));\n}\n\nfunction compressImage(photo) {\n  return async src => {\n    const img = await Image.load(src); // Store the initial dimensions\n\n    photo.startWidth = img.naturalWidth;\n    photo.startHeight = img.naturalHeight; // Resize the image\n\n    if (photo.resize) {\n      const {\n        width,\n        height\n      } = Image.resize(photo.maxWidth, photo.maxHeight)(img.naturalWidth, img.naturalHeight);\n      photo.endWidth = width;\n      photo.endHeight = height;\n    } else {\n      photo.endWidth = img.naturalWidth;\n      photo.endHeight = img.naturalHeight;\n    }\n\n    const canvas = Converter.imageToCanvas(photo.endWidth, photo.endHeight, photo.orientation)(img);\n    photo.iterations = 1;\n    photo.base64prefix = Base64.prefix(photo.ext);\n    const base64 = await loopCompression(canvas, photo.startSize, photo.quality, photo.size, photo.minQuality, photo.iterations);\n    photo.finalSize = Base64.size(base64);\n    photo.end = window.performance.now();\n    const difference = photo.end - photo.start; // in ms\n\n    return {\n      data: Base64.data(base64),\n      prefix: photo.base64prefix,\n      elapsedTimeInSeconds: difference / 1000,\n      // in seconds\n      alt: photo.alt,\n      initialSizeInMb: Converter.size(photo.startSize).MB,\n      endSizeInMb: Converter.size(photo.finalSize).MB,\n      ext: photo.ext,\n      quality: photo.quality,\n      endWidthInPx: photo.endWidth,\n      endHeightInPx: photo.endHeight,\n      initialWidthInPx: photo.startWidth,\n      initialHeightInPx: photo.startHeight,\n      sizeReducedInPercent: (photo.startSize - photo.finalSize) / photo.startSize * 100,\n      iterations: photo.iterations\n    };\n  };\n}","map":{"version":3,"sources":["C:/Users/tgound/Desktop/NCKH/Web1/frontend/node_modules/compress.js/src/index.js"],"names":["Base64","Converter","File","Image","Photo","Rotate","Compress","attach","el","options","Promise","resolve","input","document","querySelector","setAttribute","addEventListener","evt","output","compress","target","files","all","map","file","compressFile","convertBase64ToFile","base64","mime","base64ToFile","loopCompression","canvas","size","quality","targetSize","targetQuality","iterations","base64str","canvasToBase64","newSize","photo","start","window","performance","now","alt","name","ext","type","startSize","orientation","rotate","compressImage","load","src","img","startWidth","naturalWidth","startHeight","naturalHeight","resize","width","height","maxWidth","maxHeight","endWidth","endHeight","imageToCanvas","base64prefix","prefix","minQuality","finalSize","end","difference","data","elapsedTimeInSeconds","initialSizeInMb","MB","endSizeInMb","endWidthInPx","endHeightInPx","initialWidthInPx","initialHeightInPx","sizeReducedInPercent"],"mappings":"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","sourcesContent":["// Support regenerator-runtime globally.\nimport \"regenerator-runtime/runtime.js\";\n\nimport Base64 from \"./core/base64.js\";\nimport Converter from \"./core/converter.js\";\nimport File from \"./core/file.js\";\nimport Image from \"./core/image.js\";\nimport Photo from \"./core/photo.js\";\nimport Rotate from \"./core/rotate.js\";\n\n// Supported input formats\n// image/png, image/jpeg, image/jpg, image/gif, image/bmp, image/tiff, image/x-icon,  image/svg+xml, image/webp, image/xxx\n// image/png, image/jpeg, image/webp\nexport default class Compress {\n  attach(el, options) {\n    return new Promise((resolve) => {\n      const input = document.querySelector(el);\n      input.setAttribute(\"accept\", \"image/*\");\n      input.addEventListener(\n        \"change\",\n        (evt) => {\n          const output = this.compress([...evt.target.files], options);\n          resolve(output);\n        },\n        false\n      );\n    });\n  }\n\n  compress(files, options) {\n    return Promise.all(files.map((file) => compressFile(file, options)));\n  }\n\n  static convertBase64ToFile(base64, mime) {\n    return Converter.base64ToFile(base64, mime);\n  }\n}\n\nfunction loopCompression(\n  canvas,\n  size,\n  quality = 1,\n  targetSize,\n  targetQuality = 1,\n  iterations = 1\n) {\n  const base64str = Converter.canvasToBase64(canvas, quality);\n  const newSize = Base64.size(base64str);\n\n  return newSize > targetSize || quality > targetQuality\n    ? loopCompression(\n        canvas,\n        newSize,\n        quality - 0.1,\n        targetSize,\n        targetQuality,\n        iterations + 1\n      )\n    : base64str;\n}\n\nasync function compressFile(file, options) {\n  // Create a new photo object\n  const photo = new Photo(options);\n  photo.start = window.performance.now();\n  photo.alt = file.name;\n  photo.ext = file.type;\n  photo.startSize = file.size;\n  photo.orientation = photo.rotate ? await Rotate.orientation(file) : 0;\n\n  return compressImage(photo)(await File.load(file));\n}\n\nfunction compressImage(photo) {\n  return async (src) => {\n    const img = await Image.load(src);\n    // Store the initial dimensions\n    photo.startWidth = img.naturalWidth;\n    photo.startHeight = img.naturalHeight;\n\n    // Resize the image\n    if (photo.resize) {\n      const { width, height } = Image.resize(photo.maxWidth, photo.maxHeight)(\n        img.naturalWidth,\n        img.naturalHeight\n      );\n      photo.endWidth = width;\n      photo.endHeight = height;\n    } else {\n      photo.endWidth = img.naturalWidth;\n      photo.endHeight = img.naturalHeight;\n    }\n\n    const canvas = Converter.imageToCanvas(\n      photo.endWidth,\n      photo.endHeight,\n      photo.orientation\n    )(img);\n\n    photo.iterations = 1;\n    photo.base64prefix = Base64.prefix(photo.ext);\n\n    const base64 = await loopCompression(\n      canvas,\n      photo.startSize,\n      photo.quality,\n      photo.size,\n      photo.minQuality,\n      photo.iterations\n    );\n\n    photo.finalSize = Base64.size(base64);\n    photo.end = window.performance.now();\n    const difference = photo.end - photo.start; // in ms\n\n    return {\n      data: Base64.data(base64),\n      prefix: photo.base64prefix,\n      elapsedTimeInSeconds: difference / 1000, // in seconds\n      alt: photo.alt,\n      initialSizeInMb: Converter.size(photo.startSize).MB,\n      endSizeInMb: Converter.size(photo.finalSize).MB,\n      ext: photo.ext,\n      quality: photo.quality,\n      endWidthInPx: photo.endWidth,\n      endHeightInPx: photo.endHeight,\n      initialWidthInPx: photo.startWidth,\n      initialHeightInPx: photo.startHeight,\n      sizeReducedInPercent:\n        ((photo.startSize - photo.finalSize) / photo.startSize) * 100,\n      iterations: photo.iterations,\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}